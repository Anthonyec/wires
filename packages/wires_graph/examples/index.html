<style>
  body {
    margin: 0;
  }

  canvas {
    border: 1px solid red;
  }
</style>

<canvas id="canvas" width="800" height="600">

</canvas>

<script>
  window.module = { 'exports': null }
</script>
<script src="vendor/fabric.min.js"></script>
<script src="lib/graph.js"></script>
<script>
  const graph = module.exports();

  function Sin() {
    let t = 0;
    return (execute) => {
      setInterval(() => {
        t++;
        execute({ sin: Math.sin(t/100) * 100 })
      }, 1);
    };
  };

  function Slider({ dom = null }) {
    return (execute) => {
      if (!dom) {
        return;
      }

      const slider = document.createElement('input');
      slider.setAttribute('type', 'range');
      dom.appendChild(slider);

      document.addEventListener('change', (evt) => {
        execute({ progress: parseInt(slider.value) })
      });

      execute({ progress: parseInt(slider.value) })
    }
  };

  function ClearRect({ ctx, clear = false } = {}) {
    if (!ctx) {
      console.error('No ctx');
      return;
    }

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  };

  function Mouse({ target }) {
    return (execute) => {
      target.addEventListener('mousemove', (evt) => {
        execute({ x: evt.clientX, y: evt.clientY });
      });
    };
  }

  function DrawRect({ ctx = null, x = 0, y = 0, w = 100, h = 100, px = 0, py = 0 } = {}) {
    if (!ctx) {
      console.error('No ctx');
      return;
    }

    ctx.beginPath()
    ctx.strokeStyle = 'red';
    ctx.fillStyle = 'black';
    ctx.rect(x - (w * px), y - (w * py), w, h);
    ctx.fill();
    ctx.stroke();

    return { x, y, w, h };
  };

  function Log({ in1 = '' } = {}) {
    if (in1) {
      console.log('LOG:', in1);
    }

    return {};
  }

  function FabricRect({ canvas, x = 0, y = 0, w = 100, h = 100, fill = 'red' } = {}) {
    return (execute) => {
      function eventUpdate(evt) {
        execute({
          x: evt.target.left,
          y: evt.target.top,
          'x+w': evt.target.left + (evt.target.width * evt.target.scaleX),
          w: evt.target.width,
          h: evt.target.height
        });
      };

      // Bad way for now yes.
      if (!this.props._object) {
        const rect = new fabric.Rect({
          left: x,
          top: y,
          fill: fill,
          width: 100,
          height: 100
        });


        this.props._object = rect;
        this.props._object.on('modified', eventUpdate);
        this.props._object.on('moving', eventUpdate);
        this.props._object.on('scaling', eventUpdate);
        this.props._object.on('rotating', eventUpdate);

        execute({ x, y, w, h });
        canvas.add(rect);
      }

      if (this.props._object) {
        this.props._object.set({
          top: y,
          left: x,
          'x+w': x + (this.props._object.width * this.props._object.scaleX),
          width: w,
          height: h
        });

        canvas.renderAll();
      }

      execute({ x, y, w, h });
    };
  };

  // function Ease({ targetValue = 0 } = {}) {
  //   return (execute) => {
  //     if (this.props._currentValue === targetValue) {

  //     }
  //   };
  // };

  const request = graph.createComponent(({ url = ''} = {}) => {
    return (execute) => {
      setTimeout(() => {
        fetch(url).then((body) => body.text()).then((text) => {
          execute({ data: text });
        });
      }, 1000);
    };
  });

  // const rect1 = graph.createComponent(DrawRect);
  const fabricRect = graph.createComponent(FabricRect);
  const fabricRect2 = graph.createComponent(FabricRect);
  const mouse = graph.createComponent(Mouse);
  const log = graph.createComponent(Log);

  const canvas = new fabric.Canvas('canvas');

  graph.connect(mouse, 'x').to(fabricRect, 'x');
  graph.connect(mouse, 'y').to(fabricRect, 'y');

  graph.connect(fabricRect, 'x+w').to(fabricRect2, 'x');
  graph.connect(fabricRect, 'y').to(fabricRect2, 'y');

  fabricRect.setProps({ canvas });
  fabricRect2.setProps({ canvas, fill: 'blue' });
  mouse.setProps({ target: document.body });

  graph.start();
</script>
